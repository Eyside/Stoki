// lib/services/shopping_list_cloud_service.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import '../models/shopping_list_firestore.dart';
import 'auth_service.dart';
import 'group_service.dart';
import 'package:async/async.dart';

/// Service pour gérer les listes de courses dans Firestore
/// Compatible avec le modèle ShoppingListFirestore existant
class ShoppingListCloudService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final AuthService _authService = AuthService();
  final GroupService _groupService = GroupService();

  CollectionReference get _shoppingCollection => _firestore.collection('shopping_list');

  // ============================================================================
  // AJOUTER UN ARTICLE
  // ============================================================================
  Future<String> addToShoppingList({
    String? ingredientId,
    String? ingredientName,
    String? customName,
    required double quantity,
    required String unit,
    String? category,
    required bool isAutoGenerated,
    required ShoppingVisibility visibility,
    String? groupId,
    double? caloriesPer100g,
    double? proteinsPer100g,
    double? fatsPer100g,
    double? carbsPer100g,
    double? fibersPer100g,
    double? densityGPerMl,
    double? avgWeightPerUnitG,
  }) async {
    final userId = _authService.currentUser?.uid;
    if (userId == null) throw Exception('User not authenticated');

    if (visibility == ShoppingVisibility.group && groupId == null) {
      throw Exception('Group ID required for group shopping list');
    }

    final now = DateTime.now();

    final data = {
      'ownerId': userId,
      'ingredientId': ingredientId,
      'ingredientName': ingredientName,
      'customName': customName,
      'quantity': quantity,
      'unit': unit,
      'category': category,
      'status': 'pending',
      'storageLocation': null,
      'isAutoGenerated': isAutoGenerated,
      'visibility': visibility == ShoppingVisibility.group
          ? 'group'
          : visibility == ShoppingVisibility.local
          ? 'local'
          : 'private',
      'groupId': groupId,
      'caloriesPer100g': caloriesPer100g,
      'proteinsPer100g': proteinsPer100g,
      'fatsPer100g': fatsPer100g,
      'carbsPer100g': carbsPer100g,
      'fibersPer100g': fibersPer100g,
      'densityGPerMl': densityGPerMl,
      'avgWeightPerUnitG': avgWeightPerUnitG,
      'createdAt': Timestamp.fromDate(now),
      'updatedAt': Timestamp.fromDate(now),
    };

    final docRef = await _shoppingCollection.add(data);
    print('✅ Article ajouté à la liste cloud: ${docRef.id}');
    return docRef.id;
  }

  // ============================================================================
  // RÉCUPÉRER MA LISTE PRIVÉE
  // ============================================================================
  Stream<List<ShoppingListFirestore>> getMyShoppingList() {
    final userId = _authService.currentUser?.uid;
    if (userId == null) return Stream.value([]);

    return _shoppingCollection
        .where('ownerId', isEqualTo: userId)
        .where('visibility', isEqualTo: 'private')
        .orderBy('createdAt', descending: true)
        .snapshots()
        .map((snapshot) {
      return snapshot.docs
          .map((doc) => ShoppingListFirestore.fromFirestore(doc))
          .toList();
    });
  }

  // ============================================================================
  // RÉCUPÉRER LA LISTE D'UN GROUPE
  // ============================================================================
  Stream<List<ShoppingListFirestore>> getGroupShoppingList(String groupId) {
    return _shoppingCollection
        .where('groupId', isEqualTo: groupId)
        .where('visibility', isEqualTo: 'group')
        .orderBy('createdAt', descending: true)
        .snapshots()
        .map((snapshot) {
      return snapshot.docs
          .map((doc) => ShoppingListFirestore.fromFirestore(doc))
          .toList();
    });
  }

  // ============================================================================
  // RÉCUPÉRER TOUTES MES LISTES (PRIVÉ + TOUS MES GROUPES)
  // ============================================================================
  Stream<List<ShoppingListFirestore>> getAllMyLists() {
    final userId = _authService.currentUser?.uid;
    if (userId == null) return Stream.value([]);

    return _groupService.getUserGroups(userId).asyncExpand((groups) {
      final groupIds = groups.map((g) => g['id'] as String).toList();

      // Stream pour les articles personnels
      final personalItemsStream = _shoppingCollection
          .where('ownerId', isEqualTo: userId)
          .where('visibility', isEqualTo: 'private')
          .snapshots();

      if (groupIds.isEmpty) {
        return personalItemsStream.map((snapshot) {
          final items = snapshot.docs
              .map((doc) => ShoppingListFirestore.fromFirestore(doc))
              .toList();
          items.sort((a, b) => b.createdAt.compareTo(a.createdAt));
          return items;
        });
      }

      // Stream pour les articles de groupe
      final groupItemsStream = _shoppingCollection
          .where('groupId', whereIn: groupIds)
          .where('visibility', isEqualTo: 'group')
          .snapshots();

      // Combiner les deux streams
      return StreamZip([personalItemsStream, groupItemsStream]).map((results) {
        final personalDocs = results[0].docs;
        final groupDocs = results[1].docs;

        final allItems = <String, ShoppingListFirestore>{};

        for (final doc in [...personalDocs, ...groupDocs]) {
          final item = ShoppingListFirestore.fromFirestore(doc);
          allItems[item.id] = item;
        }

        final sortedList = allItems.values.toList();
        sortedList.sort((a, b) => b.createdAt.compareTo(a.createdAt));

        return sortedList;
      });
    });
  }

  // ============================================================================
  // METTRE À JOUR LE STATUT D'UN ARTICLE
  // ============================================================================
  Future<void> updateItemStatus({
    required String itemId,
    required ShoppingStatus status,
    String? storageLocation,
  }) async {
    final updates = <String, dynamic>{
      'status': status == ShoppingStatus.completed
          ? 'completed'
          : status == ShoppingStatus.stored
          ? 'stored'
          : 'pending',
      'updatedAt': Timestamp.fromDate(DateTime.now()),
    };

    if (storageLocation != null) {
      updates['storageLocation'] = storageLocation;
    }

    await _shoppingCollection.doc(itemId).update(updates);
  }

  // ============================================================================
  // MODIFIER UN ARTICLE
  // ============================================================================
  Future<void> updateItem({
    required String itemId,
    double? quantity,
    String? unit,
    String? category,
    String? customName,
  }) async {
    final updates = <String, dynamic>{
      'updatedAt': Timestamp.fromDate(DateTime.now()),
    };

    if (quantity != null) updates['quantity'] = quantity;
    if (unit != null) updates['unit'] = unit;
    if (category != null) updates['category'] = category;
    if (customName != null) updates['customName'] = customName;

    await _shoppingCollection.doc(itemId).update(updates);
  }

  // ============================================================================
  // SUPPRIMER UN ARTICLE
  // ============================================================================
  Future<void> deleteItem(String itemId) async {
    await _shoppingCollection.doc(itemId).delete();
    print('✅ Article supprimé: $itemId');
  }

  // ============================================================================
  // SUPPRIMER TOUS LES ARTICLES COMPLÉTÉS
  // ============================================================================
  Future<void> clearCompleted() async {
    final userId = _authService.currentUser?.uid;
    if (userId == null) return;

    final snapshot = await _shoppingCollection
        .where('ownerId', isEqualTo: userId)
        .where('status', isEqualTo: 'completed')
        .get();

    final batch = _firestore.batch();
    for (final doc in snapshot.docs) {
      batch.delete(doc.reference);
    }
    await batch.commit();
    print('✅ Articles complétés supprimés');
  }

  // ============================================================================
  // SUPPRIMER TOUS LES ARTICLES STOCKÉS
  // ============================================================================
  Future<void> clearStored() async {
    final userId = _authService.currentUser?.uid;
    if (userId == null) return;

    final snapshot = await _shoppingCollection
        .where('ownerId', isEqualTo: userId)
        .where('status', isEqualTo: 'stored')
        .get();

    final batch = _firestore.batch();
    for (final doc in snapshot.docs) {
      batch.delete(doc.reference);
    }
    await batch.commit();
    print('✅ Articles stockés supprimés');
  }

  // ============================================================================
  // SUPPRIMER TOUS LES ARTICLES AUTO-GÉNÉRÉS
  // ============================================================================
  Future<void> clearAutoGenerated() async {
    final userId = _authService.currentUser?.uid;
    if (userId == null) return;

    final snapshot = await _shoppingCollection
        .where('ownerId', isEqualTo: userId)
        .where('isAutoGenerated', isEqualTo: true)
        .get();

    final batch = _firestore.batch();
    for (final doc in snapshot.docs) {
      batch.delete(doc.reference);
    }
    await batch.commit();
    print('✅ Articles auto-générés supprimés');
  }

  // ============================================================================
  // SUPPRIMER TOUS LES ARTICLES (PERSO UNIQUEMENT)
  // ============================================================================
  Future<void> clearAll() async {
    final userId = _authService.currentUser?.uid;
    if (userId == null) return;

    final snapshot = await _shoppingCollection
        .where('ownerId', isEqualTo: userId)
        .where('visibility', isEqualTo: 'private')
        .get();

    final batch = _firestore.batch();
    for (final doc in snapshot.docs) {
      batch.delete(doc.reference);
    }
    await batch.commit();
    print('✅ Tous les articles personnels supprimés');
  }

  // ============================================================================
  // SUPPRIMER TOUS LES ARTICLES D'UN GROUPE
  // ============================================================================
  Future<void> clearGroupList(String groupId) async {
    final snapshot = await _shoppingCollection
        .where('groupId', isEqualTo: groupId)
        .where('visibility', isEqualTo: 'group')
        .get();

    final batch = _firestore.batch();
    for (final doc in snapshot.docs) {
      batch.delete(doc.reference);
    }
    await batch.commit();
    print('✅ Tous les articles du groupe supprimés');
  }

  // ============================================================================
  // RÉCUPÉRER UN ARTICLE SPÉCIFIQUE
  // ============================================================================
  Future<ShoppingListFirestore?> getItem(String itemId) async {
    final doc = await _shoppingCollection.doc(itemId).get();
    if (!doc.exists) return null;
    return ShoppingListFirestore.fromFirestore(doc);
  }

  // ============================================================================
  // STATISTIQUES
  // ============================================================================
  Future<Map<String, int>> getStats() async {
    final userId = _authService.currentUser?.uid;
    if (userId == null) {
      return {'total': 0, 'pending': 0, 'completed': 0, 'stored': 0};
    }

    final snapshot = await _shoppingCollection
        .where('ownerId', isEqualTo: userId)
        .get();

    final items = snapshot.docs
        .map((doc) => ShoppingListFirestore.fromFirestore(doc))
        .toList();

    return {
      'total': items.length,
      'pending': items.where((i) => i.status == ShoppingStatus.pending).length,
      'completed': items.where((i) => i.status == ShoppingStatus.completed).length,
      'stored': items.where((i) => i.status == ShoppingStatus.stored).length,
    };
  }

  // ============================================================================
  // DUPLIQUER VERS UN GROUPE
  // ============================================================================
  Future<String> duplicateToGroup({
    required String sourceItemId,
    required String groupId,
  }) async {
    final userId = _authService.currentUser?.uid;
    if (userId == null) throw Exception('User not authenticated');

    final sourceItem = await getItem(sourceItemId);
    if (sourceItem == null) throw Exception('Source item not found');

    return await addToShoppingList(
      ingredientId: sourceItem.ingredientId,
      ingredientName: sourceItem.ingredientName,
      customName: sourceItem.customName,
      quantity: sourceItem.quantity,
      unit: sourceItem.unit,
      category: sourceItem.category,
      isAutoGenerated: false,
      visibility: ShoppingVisibility.group,
      groupId: groupId,
      caloriesPer100g: sourceItem.caloriesPer100g,
      proteinsPer100g: sourceItem.proteinsPer100g,
      fatsPer100g: sourceItem.fatsPer100g,
      carbsPer100g: sourceItem.carbsPer100g,
      fibersPer100g: sourceItem.fibersPer100g,
      densityGPerMl: sourceItem.densityGPerMl,
      avgWeightPerUnitG: sourceItem.avgWeightPerUnitG,
    );
  }
}